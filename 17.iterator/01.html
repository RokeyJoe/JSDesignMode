<!-- 
    迭代器模式是只提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
    1. 为遍历不同数据结构的“集合”提供统一的接口；
    2.能遍历访问“集合”数据中的项，不关心项的数据结构。
 -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // arr = [2,4,6,8];
      // it = arr[Symbol.iterator]();
      // console.log(arr)
      // console.log(it);
      // console.log(it.next());
      // console.log(it.next());
      // console.log(it.next());
      // console.log(it.next());
      // console.log(it.next());

      // obj = {
      //     0: "Joe",
      //     1: "Ming",
      //     2: "Tyr",
      //     length:3,
      //     [Symbol.iterator]: Array.prototype[Symbol.iterator]
      // }

      // for (let t of obj) {
      //     console.log(t);
      // }

      objTest = {
        name: "Joe",
        age: 25,
        list: [1, 3, 5, 7],
        [Symbol.iterator]: function () {
          // [Symbol.iterator]的值是一个函数， 而不是值
          var index = 0;
          return {
            next: () => {
              if (index < this.list.length) {
                return {
                  value: this.list[index++],
                  done: false,
                };
              } else {
                return {
                  value: undefined,
                  done: true,
                };
              }
            },
          };
        },
      };

      ite = objTest[Symbol.iterator]();
      console.log(ite.next());
      console.log(ite.next());
      console.log(ite.next());
      console.log(ite.next());
      console.log(ite.next());
      console.log()
      for (let i of objTest) {
        console.log(i);
      }
    </script>
  </body>
</html>
